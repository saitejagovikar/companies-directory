{"ast":null,"code":"var _jsxFileName = \"/Users/govikarsaiteja/companies-directory/frontend/src/components/LightRays.jsx\",\n  _s = $RefreshSig$();\nimport { useRef, useEffect, useState } from 'react';\nimport { Renderer, Program, Triangle, Mesh } from 'ogl';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DEFAULT_COLOR = '#ffffff';\nconst hexToRgb = hex => {\n  const m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return m ? [parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255] : [1, 1, 1];\n};\nconst getAnchorAndDir = (origin, w, h) => {\n  const outside = 0.2;\n  switch (origin) {\n    case 'top-left':\n      return {\n        anchor: [0, -outside * h],\n        dir: [0, 1]\n      };\n    case 'top-right':\n      return {\n        anchor: [w, -outside * h],\n        dir: [0, 1]\n      };\n    case 'left':\n      return {\n        anchor: [-outside * w, 0.5 * h],\n        dir: [1, 0]\n      };\n    case 'right':\n      return {\n        anchor: [(1 + outside) * w, 0.5 * h],\n        dir: [-1, 0]\n      };\n    case 'bottom-left':\n      return {\n        anchor: [0, (1 + outside) * h],\n        dir: [0, -1]\n      };\n    case 'bottom-center':\n      return {\n        anchor: [0.5 * w, (1 + outside) * h],\n        dir: [0, -1]\n      };\n    case 'bottom-right':\n      return {\n        anchor: [w, (1 + outside) * h],\n        dir: [0, -1]\n      };\n    default:\n      return {\n        anchor: [0.5 * w, -outside * h],\n        dir: [0, 1]\n      };\n  }\n};\nconst LightRays = ({\n  raysOrigin = 'top-center',\n  raysColor = DEFAULT_COLOR,\n  raysSpeed = 1,\n  lightSpread = 1,\n  rayLength = 2,\n  pulsating = false,\n  fadeDistance = 1.0,\n  saturation = 1.0,\n  followMouse = true,\n  mouseInfluence = 0.1,\n  noiseAmount = 0.0,\n  distortion = 0.0,\n  className = ''\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const uniformsRef = useRef(null);\n  const rendererRef = useRef(null);\n  const mouseRef = useRef({\n    x: 0.5,\n    y: 0.5\n  });\n  const smoothMouseRef = useRef({\n    x: 0.5,\n    y: 0.5\n  });\n  const animationIdRef = useRef(null);\n  const meshRef = useRef(null);\n  const cleanupFunctionRef = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n  const observerRef = useRef(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n    observerRef.current = new IntersectionObserver(entries => {\n      const entry = entries[0];\n      setIsVisible(entry.isIntersecting);\n    }, {\n      threshold: 0.1\n    });\n    observerRef.current.observe(containerRef.current);\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n        observerRef.current = null;\n      }\n    };\n  }, []);\n  useEffect(() => {\n    if (!isVisible || !containerRef.current) return;\n\n    // Clean up any existing WebGL context\n    if (cleanupFunctionRef.current) {\n      cleanupFunctionRef.current();\n      cleanupFunctionRef.current = null;\n    }\n\n    // Ensure container has dimensions\n    const container = containerRef.current;\n    if (!container.offsetWidth || !container.offsetHeight) {\n      console.warn('Container has no dimensions, cannot initialize WebGL');\n      return;\n    }\n    const initializeWebGL = async () => {\n      if (!containerRef.current) return;\n\n      // Add a small delay to ensure the container is properly mounted\n      await new Promise(resolve => {\n        const checkReady = () => {\n          if (!containerRef.current) return resolve();\n          const container = containerRef.current;\n          if (container.offsetWidth > 0 && container.offsetHeight > 0) {\n            resolve();\n          } else {\n            requestAnimationFrame(checkReady);\n          }\n        };\n        checkReady();\n      });\n      if (!containerRef.current) return;\n      const renderer = new Renderer({\n        dpr: Math.min(window.devicePixelRatio, 2),\n        alpha: true\n      });\n      rendererRef.current = renderer;\n      const gl = renderer.gl;\n      gl.canvas.style.width = '100%';\n      gl.canvas.style.height = '100%';\n      while (containerRef.current.firstChild) {\n        containerRef.current.removeChild(containerRef.current.firstChild);\n      }\n      containerRef.current.appendChild(gl.canvas);\n      const vert = `\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n  vUv = position * 0.5 + 0.5;\n  gl_Position = vec4(position, 0.0, 1.0);\n}`;\n      const frag = `precision highp float;\nuniform float iTime;\nuniform vec2  iResolution;\nuniform vec2  rayPos;\nuniform vec2  rayDir;\nuniform vec3  raysColor;\nuniform float raysSpeed;\nuniform float lightSpread;\nuniform float rayLength;\nuniform float pulsating;\nuniform float fadeDistance;\nuniform float saturation;\nuniform vec2  mousePos;\nuniform float mouseInfluence;\nuniform float noiseAmount;\nuniform float distortion;\nvarying vec2 vUv;\nfloat noise(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,\n                  float seedA, float seedB, float speed) {\n  vec2 sourceToCoord = coord - raySource;\n  vec2 dirNorm = normalize(sourceToCoord);\n  float cosAngle = dot(dirNorm, rayRefDirection);\n  float distortedAngle = cosAngle + distortion * sin(iTime * 2.0 + length(sourceToCoord) * 0.01) * 0.2;\n  float spreadFactor = pow(max(distortedAngle, 0.0), 1.0 / max(lightSpread, 0.001));\n  float distance = length(sourceToCoord);\n  float maxDistance = iResolution.x * rayLength;\n  float lengthFalloff = clamp((maxDistance - distance) / maxDistance, 0.0, 1.0);\n  float fadeFalloff = clamp((iResolution.x * fadeDistance - distance) / (iResolution.x * fadeDistance), 0.5, 1.0);\n  float pulse = pulsating > 0.5 ? (0.8 + 0.2 * sin(iTime * speed * 3.0)) : 1.0;\n  float baseStrength = clamp(\n    (0.45 + 0.15 * sin(distortedAngle * seedA + iTime * speed)) +\n    (0.3 + 0.2 * cos(-distortedAngle * seedB + iTime * speed)),\n    0.0, 1.0\n  );\n  return baseStrength * lengthFalloff * fadeFalloff * spreadFactor * pulse;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n  vec2 finalRayDir = rayDir;\n  if (mouseInfluence > 0.0) {\n    vec2 mouseScreenPos = mousePos * iResolution.xy;\n    vec2 mouseDirection = normalize(mouseScreenPos - rayPos);\n    finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));\n  }\n  vec4 rays1 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349,\n                           1.5 * raysSpeed);\n  vec4 rays2 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234,\n                           1.1 * raysSpeed);\n  fragColor = rays1 * 0.5 + rays2 * 0.4;\n  if (noiseAmount > 0.0) {\n    float n = noise(coord * 0.01 + iTime * 0.1);\n    fragColor.rgb *= (1.0 - noiseAmount + noiseAmount * n);\n  }\n  float brightness = 1.0 - (coord.y / iResolution.y);\n  fragColor.x *= 0.1 + brightness * 0.8;\n  fragColor.y *= 0.3 + brightness * 0.6;\n  fragColor.z *= 0.5 + brightness * 0.5;\n  if (saturation != 1.0) {\n    float gray = dot(fragColor.rgb, vec3(0.299, 0.587, 0.114));\n    fragColor.rgb = mix(vec3(gray), fragColor.rgb, saturation);\n  }\n  fragColor.rgb *= raysColor;\n}\nvoid main() {\n  vec4 color;\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor  = color;\n}`;\n      const uniforms = {\n        iTime: {\n          value: 0\n        },\n        iResolution: {\n          value: [1, 1]\n        },\n        rayPos: {\n          value: [0, 0]\n        },\n        rayDir: {\n          value: [0, 1]\n        },\n        raysColor: {\n          value: hexToRgb(raysColor)\n        },\n        raysSpeed: {\n          value: raysSpeed\n        },\n        lightSpread: {\n          value: lightSpread\n        },\n        rayLength: {\n          value: rayLength\n        },\n        pulsating: {\n          value: pulsating ? 1.0 : 0.0\n        },\n        fadeDistance: {\n          value: fadeDistance\n        },\n        saturation: {\n          value: saturation\n        },\n        mousePos: {\n          value: [0.5, 0.5]\n        },\n        mouseInfluence: {\n          value: mouseInfluence\n        },\n        noiseAmount: {\n          value: noiseAmount\n        },\n        distortion: {\n          value: distortion\n        }\n      };\n      uniformsRef.current = uniforms;\n      const geometry = new Triangle(gl);\n      const program = new Program(gl, {\n        vertex: vert,\n        fragment: frag,\n        uniforms\n      });\n      const mesh = new Mesh(gl, {\n        geometry,\n        program\n      });\n      meshRef.current = mesh;\n      const updatePlacement = () => {\n        if (!containerRef.current || !renderer) return;\n        renderer.dpr = Math.min(window.devicePixelRatio, 2);\n        const {\n          clientWidth: wCSS,\n          clientHeight: hCSS\n        } = containerRef.current;\n        renderer.setSize(wCSS, hCSS);\n        const dpr = renderer.dpr;\n        const w = wCSS * dpr;\n        const h = hCSS * dpr;\n        uniforms.iResolution.value = [w, h];\n        const {\n          anchor,\n          dir\n        } = getAnchorAndDir(raysOrigin, w, h);\n        uniforms.rayPos.value = anchor;\n        uniforms.rayDir.value = dir;\n      };\n      const loop = t => {\n        if (!rendererRef.current || !uniformsRef.current || !meshRef.current) {\n          return;\n        }\n        // Update time uniform, using delta time for more consistent animation\n        uniforms.iTime.value = t * 0.001;\n        if (followMouse && mouseInfluence > 0.0) {\n          const smoothing = 0.92;\n          smoothMouseRef.current.x = smoothMouseRef.current.x * smoothing + mouseRef.current.x * (1 - smoothing);\n          smoothMouseRef.current.y = smoothMouseRef.current.y * smoothing + mouseRef.current.y * (1 - smoothing);\n          uniforms.mousePos.value = [smoothMouseRef.current.x, smoothMouseRef.current.y];\n        }\n        try {\n          renderer.render({\n            scene: mesh\n          });\n          animationIdRef.current = requestAnimationFrame(loop);\n        } catch (error) {\n          console.warn('WebGL rendering error:', error);\n          return;\n        }\n      };\n      window.addEventListener('resize', updatePlacement);\n      updatePlacement();\n      animationIdRef.current = requestAnimationFrame(loop);\n      cleanupFunctionRef.current = () => {\n        if (animationIdRef.current) {\n          cancelAnimationFrame(animationIdRef.current);\n          animationIdRef.current = null;\n        }\n        window.removeEventListener('resize', updatePlacement);\n        if (renderer) {\n          try {\n            const canvas = renderer.gl.canvas;\n            const loseContextExt = renderer.gl.getExtension('WEBGL_lose_context');\n            if (loseContextExt) {\n              loseContextExt.loseContext();\n            }\n            if (canvas && canvas.parentNode) {\n              canvas.parentNode.removeChild(canvas);\n            }\n          } catch (error) {\n            console.warn('Error during WebGL cleanup:', error);\n          }\n        }\n        rendererRef.current = null;\n        uniformsRef.current = null;\n        meshRef.current = null;\n      };\n    };\n    initializeWebGL();\n    return () => {\n      if (cleanupFunctionRef.current) {\n        cleanupFunctionRef.current();\n        cleanupFunctionRef.current = null;\n      }\n    };\n  }, [isVisible, raysOrigin, raysColor, raysSpeed, lightSpread, rayLength, pulsating, fadeDistance, saturation, followMouse, mouseInfluence, noiseAmount, distortion]);\n  useEffect(() => {\n    if (!uniformsRef.current || !containerRef.current || !rendererRef.current) return;\n    const u = uniformsRef.current;\n    const renderer = rendererRef.current;\n    u.raysColor.value = hexToRgb(raysColor);\n    u.raysSpeed.value = raysSpeed;\n    u.lightSpread.value = lightSpread;\n    u.rayLength.value = rayLength;\n    u.pulsating.value = pulsating ? 1.0 : 0.0;\n    u.fadeDistance.value = fadeDistance;\n    u.saturation.value = saturation;\n    u.mouseInfluence.value = mouseInfluence;\n    u.noiseAmount.value = noiseAmount;\n    u.distortion.value = distortion;\n    const {\n      clientWidth: wCSS,\n      clientHeight: hCSS\n    } = containerRef.current;\n    const dpr = renderer.dpr;\n    const {\n      anchor,\n      dir\n    } = getAnchorAndDir(raysOrigin, wCSS * dpr, hCSS * dpr);\n    u.rayPos.value = anchor;\n    u.rayDir.value = dir;\n  }, [raysColor, raysSpeed, lightSpread, raysOrigin, rayLength, pulsating, fadeDistance, saturation, mouseInfluence, noiseAmount, distortion]);\n  useEffect(() => {\n    const handleMouseMove = e => {\n      if (!containerRef.current || !rendererRef.current) return;\n      const rect = containerRef.current.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = (e.clientY - rect.top) / rect.height;\n      mouseRef.current = {\n        x,\n        y\n      };\n    };\n    if (followMouse) {\n      window.addEventListener('mousemove', handleMouseMove);\n      return () => window.removeEventListener('mousemove', handleMouseMove);\n    }\n  }, [followMouse]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: `w-full h-full pointer-events-none z-[1] overflow-hidden absolute inset-0 ${className}`.trim(),\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      zIndex: 1,\n      overflow: 'hidden'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 364,\n    columnNumber: 5\n  }, this);\n};\n_s(LightRays, \"gkxaG+awg9r85Ws+gbq3bog+yME=\");\n_c = LightRays;\nexport default LightRays;\nvar _c;\n$RefreshReg$(_c, \"LightRays\");","map":{"version":3,"names":["useRef","useEffect","useState","Renderer","Program","Triangle","Mesh","jsxDEV","_jsxDEV","DEFAULT_COLOR","hexToRgb","hex","m","exec","parseInt","getAnchorAndDir","origin","w","h","outside","anchor","dir","LightRays","raysOrigin","raysColor","raysSpeed","lightSpread","rayLength","pulsating","fadeDistance","saturation","followMouse","mouseInfluence","noiseAmount","distortion","className","_s","containerRef","uniformsRef","rendererRef","mouseRef","x","y","smoothMouseRef","animationIdRef","meshRef","cleanupFunctionRef","isVisible","setIsVisible","observerRef","current","IntersectionObserver","entries","entry","isIntersecting","threshold","observe","disconnect","container","offsetWidth","offsetHeight","console","warn","initializeWebGL","Promise","resolve","checkReady","requestAnimationFrame","renderer","dpr","Math","min","window","devicePixelRatio","alpha","gl","canvas","style","width","height","firstChild","removeChild","appendChild","vert","frag","uniforms","iTime","value","iResolution","rayPos","rayDir","mousePos","geometry","program","vertex","fragment","mesh","updatePlacement","clientWidth","wCSS","clientHeight","hCSS","setSize","loop","t","smoothing","render","scene","error","addEventListener","cancelAnimationFrame","removeEventListener","loseContextExt","getExtension","loseContext","parentNode","u","handleMouseMove","e","rect","getBoundingClientRect","clientX","left","clientY","top","ref","trim","position","pointerEvents","zIndex","overflow","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/govikarsaiteja/companies-directory/frontend/src/components/LightRays.jsx"],"sourcesContent":["import { useRef, useEffect, useState } from 'react';\nimport { Renderer, Program, Triangle, Mesh } from 'ogl';\n\nconst DEFAULT_COLOR = '#ffffff';\n\nconst hexToRgb = hex => {\n  const m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return m ? [parseInt(m[1], 16) / 255, parseInt(m[2], 16) / 255, parseInt(m[3], 16) / 255] : [1, 1, 1];\n};\n\nconst getAnchorAndDir = (origin, w, h) => {\n  const outside = 0.2;\n  switch (origin) {\n    case 'top-left':\n      return { anchor: [0, -outside * h], dir: [0, 1] };\n    case 'top-right':\n      return { anchor: [w, -outside * h], dir: [0, 1] };\n    case 'left':\n      return { anchor: [-outside * w, 0.5 * h], dir: [1, 0] };\n    case 'right':\n      return { anchor: [(1 + outside) * w, 0.5 * h], dir: [-1, 0] };\n    case 'bottom-left':\n      return { anchor: [0, (1 + outside) * h], dir: [0, -1] };\n    case 'bottom-center':\n      return { anchor: [0.5 * w, (1 + outside) * h], dir: [0, -1] };\n    case 'bottom-right':\n      return { anchor: [w, (1 + outside) * h], dir: [0, -1] };\n    default:\n      return { anchor: [0.5 * w, -outside * h], dir: [0, 1] };\n  }\n};\n\nconst LightRays = ({\n  raysOrigin = 'top-center',\n  raysColor = DEFAULT_COLOR,\n  raysSpeed = 1,\n  lightSpread = 1,\n  rayLength = 2,\n  pulsating = false,\n  fadeDistance = 1.0,\n  saturation = 1.0,\n  followMouse = true,\n  mouseInfluence = 0.1,\n  noiseAmount = 0.0,\n  distortion = 0.0,\n  className = ''\n}) => {\n  const containerRef = useRef(null);\n  const uniformsRef = useRef(null);\n  const rendererRef = useRef(null);\n  const mouseRef = useRef({ x: 0.5, y: 0.5 });\n  const smoothMouseRef = useRef({ x: 0.5, y: 0.5 });\n  const animationIdRef = useRef(null);\n  const meshRef = useRef(null);\n  const cleanupFunctionRef = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n  const observerRef = useRef(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n    observerRef.current = new IntersectionObserver(\n      entries => {\n        const entry = entries[0];\n        setIsVisible(entry.isIntersecting);\n      },\n      { threshold: 0.1 }\n    );\n    observerRef.current.observe(containerRef.current);\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n        observerRef.current = null;\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!isVisible || !containerRef.current) return;\n    \n    // Clean up any existing WebGL context\n    if (cleanupFunctionRef.current) {\n      cleanupFunctionRef.current();\n      cleanupFunctionRef.current = null;\n    }\n    \n    // Ensure container has dimensions\n    const container = containerRef.current;\n    if (!container.offsetWidth || !container.offsetHeight) {\n      console.warn('Container has no dimensions, cannot initialize WebGL');\n      return;\n    }\n    const initializeWebGL = async () => {\n      if (!containerRef.current) return;\n      \n      // Add a small delay to ensure the container is properly mounted\n      await new Promise(resolve => {\n        const checkReady = () => {\n          if (!containerRef.current) return resolve();\n          const container = containerRef.current;\n          if (container.offsetWidth > 0 && container.offsetHeight > 0) {\n            resolve();\n          } else {\n            requestAnimationFrame(checkReady);\n          }\n        };\n        checkReady();\n      });\n      \n      if (!containerRef.current) return;\n      const renderer = new Renderer({\n        dpr: Math.min(window.devicePixelRatio, 2),\n        alpha: true\n      });\n      rendererRef.current = renderer;\n      const gl = renderer.gl;\n      gl.canvas.style.width = '100%';\n      gl.canvas.style.height = '100%';\n      while (containerRef.current.firstChild) {\n        containerRef.current.removeChild(containerRef.current.firstChild);\n      }\n      containerRef.current.appendChild(gl.canvas);\n\n      const vert = `\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n  vUv = position * 0.5 + 0.5;\n  gl_Position = vec4(position, 0.0, 1.0);\n}`;\n\n      const frag = `precision highp float;\nuniform float iTime;\nuniform vec2  iResolution;\nuniform vec2  rayPos;\nuniform vec2  rayDir;\nuniform vec3  raysColor;\nuniform float raysSpeed;\nuniform float lightSpread;\nuniform float rayLength;\nuniform float pulsating;\nuniform float fadeDistance;\nuniform float saturation;\nuniform vec2  mousePos;\nuniform float mouseInfluence;\nuniform float noiseAmount;\nuniform float distortion;\nvarying vec2 vUv;\nfloat noise(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,\n                  float seedA, float seedB, float speed) {\n  vec2 sourceToCoord = coord - raySource;\n  vec2 dirNorm = normalize(sourceToCoord);\n  float cosAngle = dot(dirNorm, rayRefDirection);\n  float distortedAngle = cosAngle + distortion * sin(iTime * 2.0 + length(sourceToCoord) * 0.01) * 0.2;\n  float spreadFactor = pow(max(distortedAngle, 0.0), 1.0 / max(lightSpread, 0.001));\n  float distance = length(sourceToCoord);\n  float maxDistance = iResolution.x * rayLength;\n  float lengthFalloff = clamp((maxDistance - distance) / maxDistance, 0.0, 1.0);\n  float fadeFalloff = clamp((iResolution.x * fadeDistance - distance) / (iResolution.x * fadeDistance), 0.5, 1.0);\n  float pulse = pulsating > 0.5 ? (0.8 + 0.2 * sin(iTime * speed * 3.0)) : 1.0;\n  float baseStrength = clamp(\n    (0.45 + 0.15 * sin(distortedAngle * seedA + iTime * speed)) +\n    (0.3 + 0.2 * cos(-distortedAngle * seedB + iTime * speed)),\n    0.0, 1.0\n  );\n  return baseStrength * lengthFalloff * fadeFalloff * spreadFactor * pulse;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n  vec2 finalRayDir = rayDir;\n  if (mouseInfluence > 0.0) {\n    vec2 mouseScreenPos = mousePos * iResolution.xy;\n    vec2 mouseDirection = normalize(mouseScreenPos - rayPos);\n    finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));\n  }\n  vec4 rays1 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349,\n                           1.5 * raysSpeed);\n  vec4 rays2 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234,\n                           1.1 * raysSpeed);\n  fragColor = rays1 * 0.5 + rays2 * 0.4;\n  if (noiseAmount > 0.0) {\n    float n = noise(coord * 0.01 + iTime * 0.1);\n    fragColor.rgb *= (1.0 - noiseAmount + noiseAmount * n);\n  }\n  float brightness = 1.0 - (coord.y / iResolution.y);\n  fragColor.x *= 0.1 + brightness * 0.8;\n  fragColor.y *= 0.3 + brightness * 0.6;\n  fragColor.z *= 0.5 + brightness * 0.5;\n  if (saturation != 1.0) {\n    float gray = dot(fragColor.rgb, vec3(0.299, 0.587, 0.114));\n    fragColor.rgb = mix(vec3(gray), fragColor.rgb, saturation);\n  }\n  fragColor.rgb *= raysColor;\n}\nvoid main() {\n  vec4 color;\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor  = color;\n}`;\n\n      const uniforms = {\n        iTime: { value: 0 },\n        iResolution: { value: [1, 1] },\n        rayPos: { value: [0, 0] },\n        rayDir: { value: [0, 1] },\n        raysColor: { value: hexToRgb(raysColor) },\n        raysSpeed: { value: raysSpeed },\n        lightSpread: { value: lightSpread },\n        rayLength: { value: rayLength },\n        pulsating: { value: pulsating ? 1.0 : 0.0 },\n        fadeDistance: { value: fadeDistance },\n        saturation: { value: saturation },\n        mousePos: { value: [0.5, 0.5] },\n        mouseInfluence: { value: mouseInfluence },\n        noiseAmount: { value: noiseAmount },\n        distortion: { value: distortion }\n      };\n      uniformsRef.current = uniforms;\n\n      const geometry = new Triangle(gl);\n      const program = new Program(gl, { vertex: vert, fragment: frag, uniforms });\n      const mesh = new Mesh(gl, { geometry, program });\n      meshRef.current = mesh;\n\n      const updatePlacement = () => {\n        if (!containerRef.current || !renderer) return;\n        renderer.dpr = Math.min(window.devicePixelRatio, 2);\n        const { clientWidth: wCSS, clientHeight: hCSS } = containerRef.current;\n        renderer.setSize(wCSS, hCSS);\n        const dpr = renderer.dpr;\n        const w = wCSS * dpr;\n        const h = hCSS * dpr;\n        uniforms.iResolution.value = [w, h];\n        const { anchor, dir } = getAnchorAndDir(raysOrigin, w, h);\n        uniforms.rayPos.value = anchor;\n        uniforms.rayDir.value = dir;\n      };\n\n      const loop = t => {\n        if (!rendererRef.current || !uniformsRef.current || !meshRef.current) {\n          return;\n        }\n        // Update time uniform, using delta time for more consistent animation\n        uniforms.iTime.value = t * 0.001;\n        if (followMouse && mouseInfluence > 0.0) {\n          const smoothing = 0.92;\n          smoothMouseRef.current.x = smoothMouseRef.current.x * smoothing + mouseRef.current.x * (1 - smoothing);\n          smoothMouseRef.current.y = smoothMouseRef.current.y * smoothing + mouseRef.current.y * (1 - smoothing);\n          uniforms.mousePos.value = [smoothMouseRef.current.x, smoothMouseRef.current.y];\n        }\n        try {\n          renderer.render({ scene: mesh });\n          animationIdRef.current = requestAnimationFrame(loop);\n        } catch (error) {\n          console.warn('WebGL rendering error:', error);\n          return;\n        }\n      };\n\n      window.addEventListener('resize', updatePlacement);\n      updatePlacement();\n      animationIdRef.current = requestAnimationFrame(loop);\n\n      cleanupFunctionRef.current = () => {\n        if (animationIdRef.current) {\n          cancelAnimationFrame(animationIdRef.current);\n          animationIdRef.current = null;\n        }\n        window.removeEventListener('resize', updatePlacement);\n        if (renderer) {\n          try {\n            const canvas = renderer.gl.canvas;\n            const loseContextExt = renderer.gl.getExtension('WEBGL_lose_context');\n            if (loseContextExt) {\n              loseContextExt.loseContext();\n            }\n            if (canvas && canvas.parentNode) {\n              canvas.parentNode.removeChild(canvas);\n            }\n          } catch (error) {\n            console.warn('Error during WebGL cleanup:', error);\n          }\n        }\n        rendererRef.current = null;\n        uniformsRef.current = null;\n        meshRef.current = null;\n      };\n    };\n    initializeWebGL();\n    return () => {\n      if (cleanupFunctionRef.current) {\n        cleanupFunctionRef.current();\n        cleanupFunctionRef.current = null;\n      }\n    };\n  }, [\n    isVisible,\n    raysOrigin,\n    raysColor,\n    raysSpeed,\n    lightSpread,\n    rayLength,\n    pulsating,\n    fadeDistance,\n    saturation,\n    followMouse,\n    mouseInfluence,\n    noiseAmount,\n    distortion\n  ]);\n\n  useEffect(() => {\n    if (!uniformsRef.current || !containerRef.current || !rendererRef.current) return;\n    const u = uniformsRef.current;\n    const renderer = rendererRef.current;\n    u.raysColor.value = hexToRgb(raysColor);\n    u.raysSpeed.value = raysSpeed;\n    u.lightSpread.value = lightSpread;\n    u.rayLength.value = rayLength;\n    u.pulsating.value = pulsating ? 1.0 : 0.0;\n    u.fadeDistance.value = fadeDistance;\n    u.saturation.value = saturation;\n    u.mouseInfluence.value = mouseInfluence;\n    u.noiseAmount.value = noiseAmount;\n    u.distortion.value = distortion;\n    const { clientWidth: wCSS, clientHeight: hCSS } = containerRef.current;\n    const dpr = renderer.dpr;\n    const { anchor, dir } = getAnchorAndDir(raysOrigin, wCSS * dpr, hCSS * dpr);\n    u.rayPos.value = anchor;\n    u.rayDir.value = dir;\n  }, [\n    raysColor,\n    raysSpeed,\n    lightSpread,\n    raysOrigin,\n    rayLength,\n    pulsating,\n    fadeDistance,\n    saturation,\n    mouseInfluence,\n    noiseAmount,\n    distortion\n  ]);\n\n  useEffect(() => {\n    const handleMouseMove = e => {\n      if (!containerRef.current || !rendererRef.current) return;\n      const rect = containerRef.current.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = (e.clientY - rect.top) / rect.height;\n      mouseRef.current = { x, y };\n    };\n    if (followMouse) {\n      window.addEventListener('mousemove', handleMouseMove);\n      return () => window.removeEventListener('mousemove', handleMouseMove);\n    }\n  }, [followMouse]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`w-full h-full pointer-events-none z-[1] overflow-hidden absolute inset-0 ${className}`.trim()}\n      style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        pointerEvents: 'none',\n        zIndex: 1,\n        overflow: 'hidden'\n      }}\n    />\n  );\n};\n\nexport default LightRays;\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}