{"ast":null,"code":"// TODO: barycentric code shouldn't be here, but where?\n// TODO: SphereCast?\n\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Mat4 } from '../math/Mat4.js';\nconst tempVec2a = new Vec2();\nconst tempVec2b = new Vec2();\nconst tempVec2c = new Vec2();\nconst tempVec3a = new Vec3();\nconst tempVec3b = new Vec3();\nconst tempVec3c = new Vec3();\nconst tempVec3d = new Vec3();\nconst tempVec3e = new Vec3();\nconst tempVec3f = new Vec3();\nconst tempVec3g = new Vec3();\nconst tempVec3h = new Vec3();\nconst tempVec3i = new Vec3();\nconst tempVec3j = new Vec3();\nconst tempVec3k = new Vec3();\nconst tempMat4 = new Mat4();\nexport class Raycast {\n  constructor() {\n    this.origin = new Vec3();\n    this.direction = new Vec3();\n  }\n\n  // Set ray from mouse unprojection\n  castMouse(camera, mouse = [0, 0]) {\n    if (camera.type === 'orthographic') {\n      // Set origin\n      // Since camera is orthographic, origin is not the camera position\n      const {\n        left,\n        right,\n        bottom,\n        top,\n        zoom\n      } = camera;\n      const x = left / zoom + (right - left) / zoom * (mouse[0] * 0.5 + 0.5);\n      const y = bottom / zoom + (top - bottom) / zoom * (mouse[1] * 0.5 + 0.5);\n      this.origin.set(x, y, 0);\n      this.origin.applyMatrix4(camera.worldMatrix);\n\n      // Set direction\n      // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n      this.direction.x = -camera.worldMatrix[8];\n      this.direction.y = -camera.worldMatrix[9];\n      this.direction.z = -camera.worldMatrix[10];\n    } else {\n      // Set origin\n      camera.worldMatrix.getTranslation(this.origin);\n\n      // Set direction\n      this.direction.set(mouse[0], mouse[1], 0.5);\n      camera.unproject(this.direction);\n      this.direction.sub(this.origin).normalize();\n    }\n  }\n  intersectBounds(meshes, {\n    maxDistance,\n    output = []\n  } = {}) {\n    if (!Array.isArray(meshes)) meshes = [meshes];\n    const invWorldMat4 = tempMat4;\n    const origin = tempVec3a;\n    const direction = tempVec3b;\n    const hits = output;\n    hits.length = 0;\n    meshes.forEach(mesh => {\n      // Create bounds\n      if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n      const bounds = mesh.geometry.bounds;\n      invWorldMat4.inverse(mesh.worldMatrix);\n\n      // Get max distance locally\n      let localMaxDistance;\n      if (maxDistance) {\n        direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n        localMaxDistance = maxDistance * direction.len();\n      }\n\n      // Take world space ray and make it object space to align with bounding box\n      origin.copy(this.origin).applyMatrix4(invWorldMat4);\n      direction.copy(this.direction).transformDirection(invWorldMat4);\n\n      // Break out early if bounds too far away from origin\n      if (maxDistance) {\n        if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n      }\n      let localDistance = 0;\n\n      // Check origin isn't inside bounds before testing intersection\n      if (mesh.geometry.raycast === 'sphere') {\n        if (origin.distance(bounds.center) > bounds.radius) {\n          localDistance = this.intersectSphere(bounds, origin, direction);\n          if (!localDistance) return;\n        }\n      } else {\n        if (origin.x < bounds.min.x || origin.x > bounds.max.x || origin.y < bounds.min.y || origin.y > bounds.max.y || origin.z < bounds.min.z || origin.z > bounds.max.z) {\n          localDistance = this.intersectBox(bounds, origin, direction);\n          if (!localDistance) return;\n        }\n      }\n      if (maxDistance && localDistance > localMaxDistance) return;\n\n      // Create object on mesh to avoid generating lots of objects\n      if (!mesh.hit) mesh.hit = {\n        localPoint: new Vec3(),\n        point: new Vec3()\n      };\n      mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n      mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n      mesh.hit.distance = mesh.hit.point.distance(this.origin);\n      hits.push(mesh);\n    });\n    hits.sort((a, b) => a.hit.distance - b.hit.distance);\n    return hits;\n  }\n  intersectMeshes(meshes, {\n    cullFace = true,\n    maxDistance,\n    includeUV = true,\n    includeNormal = true,\n    output = []\n  } = {}) {\n    // Test bounds first before testing geometry\n    const hits = this.intersectBounds(meshes, {\n      maxDistance,\n      output\n    });\n    if (!hits.length) return hits;\n    const invWorldMat4 = tempMat4;\n    const origin = tempVec3a;\n    const direction = tempVec3b;\n    const a = tempVec3c;\n    const b = tempVec3d;\n    const c = tempVec3e;\n    const closestFaceNormal = tempVec3f;\n    const faceNormal = tempVec3g;\n    const barycoord = tempVec3h;\n    const uvA = tempVec2a;\n    const uvB = tempVec2b;\n    const uvC = tempVec2c;\n    for (let i = hits.length - 1; i >= 0; i--) {\n      const mesh = hits[i];\n      invWorldMat4.inverse(mesh.worldMatrix);\n\n      // Get max distance locally\n      let localMaxDistance;\n      if (maxDistance) {\n        direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n        localMaxDistance = maxDistance * direction.len();\n      }\n\n      // Take world space ray and make it object space to align with bounding box\n      origin.copy(this.origin).applyMatrix4(invWorldMat4);\n      direction.copy(this.direction).transformDirection(invWorldMat4);\n      let localDistance = 0;\n      let closestA, closestB, closestC;\n      const geometry = mesh.geometry;\n      const attributes = geometry.attributes;\n      const index = attributes.index;\n      const position = attributes.position;\n      const start = Math.max(0, geometry.drawRange.start);\n      const end = Math.min(index ? index.count : position.count, geometry.drawRange.start + geometry.drawRange.count);\n      const stride = position.stride ? position.stride / position.data.BYTES_PER_ELEMENT : position.size;\n      for (let j = start; j < end; j += 3) {\n        // Position attribute indices for each triangle\n        const ai = index ? index.data[j] : j;\n        const bi = index ? index.data[j + 1] : j + 1;\n        const ci = index ? index.data[j + 2] : j + 2;\n        a.fromArray(position.data, ai * stride);\n        b.fromArray(position.data, bi * stride);\n        c.fromArray(position.data, ci * stride);\n        const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n        if (!distance) continue;\n\n        // Too far away\n        if (maxDistance && distance > localMaxDistance) continue;\n        if (!localDistance || distance < localDistance) {\n          localDistance = distance;\n          closestA = ai;\n          closestB = bi;\n          closestC = ci;\n          closestFaceNormal.copy(faceNormal);\n        }\n      }\n      if (!localDistance) hits.splice(i, 1);\n\n      // Update hit values from bounds-test\n      mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n      mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n      mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n      // Add unique hit objects on mesh to avoid generating lots of objects\n      if (!mesh.hit.faceNormal) {\n        mesh.hit.localFaceNormal = new Vec3();\n        mesh.hit.faceNormal = new Vec3();\n        mesh.hit.uv = new Vec2();\n        mesh.hit.localNormal = new Vec3();\n        mesh.hit.normal = new Vec3();\n      }\n\n      // Add face normal data which is already computed\n      mesh.hit.localFaceNormal.copy(closestFaceNormal);\n      mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix);\n\n      // Optional data, opt out to optimise a bit if necessary\n      if (includeUV || includeNormal) {\n        // Calculate barycoords to find uv values at hit point\n        a.fromArray(position.data, closestA * 3);\n        b.fromArray(position.data, closestB * 3);\n        c.fromArray(position.data, closestC * 3);\n        this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n      }\n      if (includeUV && attributes.uv) {\n        uvA.fromArray(attributes.uv.data, closestA * 2);\n        uvB.fromArray(attributes.uv.data, closestB * 2);\n        uvC.fromArray(attributes.uv.data, closestC * 2);\n        mesh.hit.uv.set(uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z, uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z);\n      }\n      if (includeNormal && attributes.normal) {\n        a.fromArray(attributes.normal.data, closestA * 3);\n        b.fromArray(attributes.normal.data, closestB * 3);\n        c.fromArray(attributes.normal.data, closestC * 3);\n        mesh.hit.localNormal.set(a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z, a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z, a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z);\n        mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n      }\n    }\n    hits.sort((a, b) => a.hit.distance - b.hit.distance);\n    return hits;\n  }\n  intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n    const ray = tempVec3c;\n    ray.sub(sphere.center, origin);\n    const tca = ray.dot(direction);\n    const d2 = ray.dot(ray) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return 0;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 = tca - thc;\n    const t1 = tca + thc;\n    if (t0 < 0 && t1 < 0) return 0;\n    if (t0 < 0) return t1;\n    return t0;\n  }\n\n  // Ray AABB - Ray Axis aligned bounding box testing\n  intersectBox(box, origin = this.origin, direction = this.direction) {\n    let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n    const invdirx = 1 / direction.x;\n    const invdiry = 1 / direction.y;\n    const invdirz = 1 / direction.z;\n    const min = box.min;\n    const max = box.max;\n    tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n    tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n    tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n    tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n    if (tmin > tYmax || tYmin > tmax) return 0;\n    if (tYmin > tmin) tmin = tYmin;\n    if (tYmax < tmax) tmax = tYmax;\n    tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n    tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n    if (tmin > tZmax || tZmin > tmax) return 0;\n    if (tZmin > tmin) tmin = tZmin;\n    if (tZmax < tmax) tmax = tZmax;\n    if (tmax < 0) return 0;\n    return tmin >= 0 ? tmin : tmax;\n  }\n  intersectTriangle(a, b, c, backfaceCulling = true, origin = this.origin, direction = this.direction, normal = tempVec3g) {\n    // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n    // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n    const edge1 = tempVec3h;\n    const edge2 = tempVec3i;\n    const diff = tempVec3j;\n    edge1.sub(b, a);\n    edge2.sub(c, a);\n    normal.cross(edge1, edge2);\n    let DdN = direction.dot(normal);\n    if (!DdN) return 0;\n    let sign;\n    if (DdN > 0) {\n      if (backfaceCulling) return 0;\n      sign = 1;\n    } else {\n      sign = -1;\n      DdN = -DdN;\n    }\n    diff.sub(origin, a);\n    let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n    if (DdQxE2 < 0) return 0;\n    let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n    if (DdE1xQ < 0) return 0;\n    if (DdQxE2 + DdE1xQ > DdN) return 0;\n    let QdN = -sign * diff.dot(normal);\n    if (QdN < 0) return 0;\n    return QdN / DdN;\n  }\n  getBarycoord(point, a, b, c, target = tempVec3h) {\n    // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    const v0 = tempVec3i;\n    const v1 = tempVec3j;\n    const v2 = tempVec3k;\n    v0.sub(c, a);\n    v1.sub(b, a);\n    v2.sub(point, a);\n    const dot00 = v0.dot(v0);\n    const dot01 = v0.dot(v1);\n    const dot02 = v0.dot(v2);\n    const dot11 = v1.dot(v1);\n    const dot12 = v1.dot(v2);\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (denom === 0) return target.set(-2, -1, -1);\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return target.set(1 - u - v, v, u);\n  }\n}","map":{"version":3,"names":["Vec2","Vec3","Mat4","tempVec2a","tempVec2b","tempVec2c","tempVec3a","tempVec3b","tempVec3c","tempVec3d","tempVec3e","tempVec3f","tempVec3g","tempVec3h","tempVec3i","tempVec3j","tempVec3k","tempMat4","Raycast","constructor","origin","direction","castMouse","camera","mouse","type","left","right","bottom","top","zoom","x","y","set","applyMatrix4","worldMatrix","z","getTranslation","unproject","sub","normalize","intersectBounds","meshes","maxDistance","output","Array","isArray","invWorldMat4","hits","length","forEach","mesh","geometry","bounds","radius","Infinity","computeBoundingSphere","inverse","localMaxDistance","copy","scaleRotateMatrix4","len","transformDirection","distance","center","localDistance","raycast","intersectSphere","min","max","intersectBox","hit","localPoint","point","multiply","add","push","sort","a","b","intersectMeshes","cullFace","includeUV","includeNormal","c","closestFaceNormal","faceNormal","barycoord","uvA","uvB","uvC","i","closestA","closestB","closestC","attributes","index","position","start","Math","drawRange","end","count","stride","data","BYTES_PER_ELEMENT","size","j","ai","bi","ci","fromArray","intersectTriangle","splice","localFaceNormal","uv","localNormal","normal","getBarycoord","sphere","ray","tca","dot","d2","radius2","thc","sqrt","t0","t1","box","tmin","tmax","tYmin","tYmax","tZmin","tZmax","invdirx","invdiry","invdirz","backfaceCulling","edge1","edge2","diff","cross","DdN","sign","DdQxE2","DdE1xQ","QdN","target","v0","v1","v2","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","v"],"sources":["/Users/govikarsaiteja/companies-directory/frontend/node_modules/ogl/src/extras/Raycast.js"],"sourcesContent":["// TODO: barycentric code shouldn't be here, but where?\n// TODO: SphereCast?\n\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nconst tempVec2a = new Vec2();\nconst tempVec2b = new Vec2();\nconst tempVec2c = new Vec2();\n\nconst tempVec3a = new Vec3();\nconst tempVec3b = new Vec3();\nconst tempVec3c = new Vec3();\nconst tempVec3d = new Vec3();\nconst tempVec3e = new Vec3();\nconst tempVec3f = new Vec3();\nconst tempVec3g = new Vec3();\nconst tempVec3h = new Vec3();\nconst tempVec3i = new Vec3();\nconst tempVec3j = new Vec3();\nconst tempVec3k = new Vec3();\n\nconst tempMat4 = new Mat4();\n\nexport class Raycast {\n    constructor() {\n        this.origin = new Vec3();\n        this.direction = new Vec3();\n    }\n\n    // Set ray from mouse unprojection\n    castMouse(camera, mouse = [0, 0]) {\n        if (camera.type === 'orthographic') {\n            // Set origin\n            // Since camera is orthographic, origin is not the camera position\n            const { left, right, bottom, top, zoom } = camera;\n            const x = left / zoom + ((right - left) / zoom) * (mouse[0] * 0.5 + 0.5);\n            const y = bottom / zoom + ((top - bottom) / zoom) * (mouse[1] * 0.5 + 0.5);\n            this.origin.set(x, y, 0);\n            this.origin.applyMatrix4(camera.worldMatrix);\n\n            // Set direction\n            // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n            this.direction.x = -camera.worldMatrix[8];\n            this.direction.y = -camera.worldMatrix[9];\n            this.direction.z = -camera.worldMatrix[10];\n        } else {\n            // Set origin\n            camera.worldMatrix.getTranslation(this.origin);\n\n            // Set direction\n            this.direction.set(mouse[0], mouse[1], 0.5);\n            camera.unproject(this.direction);\n            this.direction.sub(this.origin).normalize();\n        }\n    }\n\n    intersectBounds(meshes, { maxDistance, output = [] } = {}) {\n        if (!Array.isArray(meshes)) meshes = [meshes];\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n\n        const hits = output;\n        hits.length = 0;\n\n        meshes.forEach((mesh) => {\n            // Create bounds\n            if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n            const bounds = mesh.geometry.bounds;\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            // Break out early if bounds too far away from origin\n            if (maxDistance) {\n                if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n            }\n\n            let localDistance = 0;\n\n            // Check origin isn't inside bounds before testing intersection\n            if (mesh.geometry.raycast === 'sphere') {\n                if (origin.distance(bounds.center) > bounds.radius) {\n                    localDistance = this.intersectSphere(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            } else {\n                if (\n                    origin.x < bounds.min.x ||\n                    origin.x > bounds.max.x ||\n                    origin.y < bounds.min.y ||\n                    origin.y > bounds.max.y ||\n                    origin.z < bounds.min.z ||\n                    origin.z > bounds.max.z\n                ) {\n                    localDistance = this.intersectBox(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            }\n\n            if (maxDistance && localDistance > localMaxDistance) return;\n\n            // Create object on mesh to avoid generating lots of objects\n            if (!mesh.hit) mesh.hit = { localPoint: new Vec3(), point: new Vec3() };\n\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            hits.push(mesh);\n        });\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectMeshes(meshes, { cullFace = true, maxDistance, includeUV = true, includeNormal = true, output = [] } = {}) {\n        // Test bounds first before testing geometry\n        const hits = this.intersectBounds(meshes, { maxDistance, output });\n        if (!hits.length) return hits;\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n        const a = tempVec3c;\n        const b = tempVec3d;\n        const c = tempVec3e;\n        const closestFaceNormal = tempVec3f;\n        const faceNormal = tempVec3g;\n        const barycoord = tempVec3h;\n        const uvA = tempVec2a;\n        const uvB = tempVec2b;\n        const uvC = tempVec2c;\n\n        for (let i = hits.length - 1; i >= 0; i--) {\n            const mesh = hits[i];\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            let localDistance = 0;\n            let closestA, closestB, closestC;\n\n            const geometry = mesh.geometry;\n            const attributes = geometry.attributes;\n            const index = attributes.index;\n            const position = attributes.position;\n\n            const start = Math.max(0, geometry.drawRange.start);\n            const end = Math.min(index ? index.count : position.count, geometry.drawRange.start + geometry.drawRange.count);\n            const stride = position.stride ? position.stride / position.data.BYTES_PER_ELEMENT : position.size;\n\n            for (let j = start; j < end; j += 3) {\n                // Position attribute indices for each triangle\n                const ai = index ? index.data[j] : j;\n                const bi = index ? index.data[j + 1] : j + 1;\n                const ci = index ? index.data[j + 2] : j + 2;\n\n                a.fromArray(position.data, ai * stride);\n                b.fromArray(position.data, bi * stride);\n                c.fromArray(position.data, ci * stride);\n\n                const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n                if (!distance) continue;\n\n                // Too far away\n                if (maxDistance && distance > localMaxDistance) continue;\n\n                if (!localDistance || distance < localDistance) {\n                    localDistance = distance;\n                    closestA = ai;\n                    closestB = bi;\n                    closestC = ci;\n                    closestFaceNormal.copy(faceNormal);\n                }\n            }\n\n            if (!localDistance) hits.splice(i, 1);\n\n            // Update hit values from bounds-test\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            // Add unique hit objects on mesh to avoid generating lots of objects\n            if (!mesh.hit.faceNormal) {\n                mesh.hit.localFaceNormal = new Vec3();\n                mesh.hit.faceNormal = new Vec3();\n                mesh.hit.uv = new Vec2();\n                mesh.hit.localNormal = new Vec3();\n                mesh.hit.normal = new Vec3();\n            }\n\n            // Add face normal data which is already computed\n            mesh.hit.localFaceNormal.copy(closestFaceNormal);\n            mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix);\n\n            // Optional data, opt out to optimise a bit if necessary\n            if (includeUV || includeNormal) {\n                // Calculate barycoords to find uv values at hit point\n                a.fromArray(position.data, closestA * 3);\n                b.fromArray(position.data, closestB * 3);\n                c.fromArray(position.data, closestC * 3);\n                this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n            }\n\n            if (includeUV && attributes.uv) {\n                uvA.fromArray(attributes.uv.data, closestA * 2);\n                uvB.fromArray(attributes.uv.data, closestB * 2);\n                uvC.fromArray(attributes.uv.data, closestC * 2);\n                mesh.hit.uv.set(\n                    uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z,\n                    uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z\n                );\n            }\n\n            if (includeNormal && attributes.normal) {\n                a.fromArray(attributes.normal.data, closestA * 3);\n                b.fromArray(attributes.normal.data, closestB * 3);\n                c.fromArray(attributes.normal.data, closestC * 3);\n                mesh.hit.localNormal.set(\n                    a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z,\n                    a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z,\n                    a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z\n                );\n\n                mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n            }\n        }\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n        const ray = tempVec3c;\n        ray.sub(sphere.center, origin);\n        const tca = ray.dot(direction);\n        const d2 = ray.dot(ray) - tca * tca;\n        const radius2 = sphere.radius * sphere.radius;\n        if (d2 > radius2) return 0;\n        const thc = Math.sqrt(radius2 - d2);\n        const t0 = tca - thc;\n        const t1 = tca + thc;\n        if (t0 < 0 && t1 < 0) return 0;\n        if (t0 < 0) return t1;\n        return t0;\n    }\n\n    // Ray AABB - Ray Axis aligned bounding box testing\n    intersectBox(box, origin = this.origin, direction = this.direction) {\n        let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n        const invdirx = 1 / direction.x;\n        const invdiry = 1 / direction.y;\n        const invdirz = 1 / direction.z;\n        const min = box.min;\n        const max = box.max;\n        tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n        tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n        tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n        tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n        if (tmin > tYmax || tYmin > tmax) return 0;\n        if (tYmin > tmin) tmin = tYmin;\n        if (tYmax < tmax) tmax = tYmax;\n        tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n        tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n        if (tmin > tZmax || tZmin > tmax) return 0;\n        if (tZmin > tmin) tmin = tZmin;\n        if (tZmax < tmax) tmax = tZmax;\n        if (tmax < 0) return 0;\n        return tmin >= 0 ? tmin : tmax;\n    }\n\n    intersectTriangle(a, b, c, backfaceCulling = true, origin = this.origin, direction = this.direction, normal = tempVec3g) {\n        // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n        // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n        const edge1 = tempVec3h;\n        const edge2 = tempVec3i;\n        const diff = tempVec3j;\n        edge1.sub(b, a);\n        edge2.sub(c, a);\n        normal.cross(edge1, edge2);\n        let DdN = direction.dot(normal);\n        if (!DdN) return 0;\n        let sign;\n        if (DdN > 0) {\n            if (backfaceCulling) return 0;\n            sign = 1;\n        } else {\n            sign = -1;\n            DdN = -DdN;\n        }\n        diff.sub(origin, a);\n        let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n        if (DdQxE2 < 0) return 0;\n        let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n        if (DdE1xQ < 0) return 0;\n        if (DdQxE2 + DdE1xQ > DdN) return 0;\n        let QdN = -sign * diff.dot(normal);\n        if (QdN < 0) return 0;\n        return QdN / DdN;\n    }\n\n    getBarycoord(point, a, b, c, target = tempVec3h) {\n        // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n        // static/instance method to calculate barycentric coordinates\n        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n        const v0 = tempVec3i;\n        const v1 = tempVec3j;\n        const v2 = tempVec3k;\n        v0.sub(c, a);\n        v1.sub(b, a);\n        v2.sub(point, a);\n        const dot00 = v0.dot(v0);\n        const dot01 = v0.dot(v1);\n        const dot02 = v0.dot(v2);\n        const dot11 = v1.dot(v1);\n        const dot12 = v1.dot(v2);\n        const denom = dot00 * dot11 - dot01 * dot01;\n        if (denom === 0) return target.set(-2, -1, -1);\n        const invDenom = 1 / denom;\n        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n        return target.set(1 - u - v, v, u);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}