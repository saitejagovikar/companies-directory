{"ast":null,"code":"import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Texture } from '../core/Texture.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\nexport class GPGPU {\n  constructor(gl, {\n    // Always pass in array of vec4s (RGBA values within texture)\n    data = new Float32Array(16),\n    geometry = new Triangle(gl),\n    type // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n  }) {\n    this.gl = gl;\n    const initialData = data;\n    this.passes = [];\n    this.geometry = geometry;\n    this.dataLength = initialData.length / 4;\n\n    // Windows and iOS only like power of 2 textures\n    // Find smallest PO2 that fits data\n    this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2));\n\n    // Create coords for output texture\n    this.coords = new Float32Array(this.dataLength * 2);\n    for (let i = 0; i < this.dataLength; i++) {\n      const x = i % this.size / this.size; // to add 0.5 to be center pixel ?\n      const y = Math.floor(i / this.size) / this.size;\n      this.coords.set([x, y], i * 2);\n    }\n\n    // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n    const floatArray = (() => {\n      if (initialData.length === this.size * this.size * 4) {\n        return initialData;\n      } else {\n        const a = new Float32Array(this.size * this.size * 4);\n        a.set(initialData);\n        return a;\n      }\n    })();\n\n    // Create output texture uniform using input float texture with initial data\n    this.uniform = {\n      value: new Texture(gl, {\n        image: floatArray,\n        target: gl.TEXTURE_2D,\n        type: gl.FLOAT,\n        format: gl.RGBA,\n        internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        generateMipmaps: false,\n        minFilter: gl.NEAREST,\n        magFilter: gl.NEAREST,\n        width: this.size,\n        flipY: false\n      })\n    };\n\n    // Create FBOs\n    const options = {\n      width: this.size,\n      height: this.size,\n      type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n      format: gl.RGBA,\n      internalFormat: gl.renderer.isWebgl2 ? type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F : gl.RGBA,\n      minFilter: gl.NEAREST,\n      depth: false,\n      unpackAlignment: 1\n    };\n    this.fbo = {\n      read: new RenderTarget(gl, options),\n      write: new RenderTarget(gl, options),\n      swap: () => {\n        let temp = this.fbo.read;\n        this.fbo.read = this.fbo.write;\n        this.fbo.write = temp;\n        this.uniform.value = this.fbo.read.texture;\n      }\n    };\n  }\n  addPass({\n    vertex = defaultVertex,\n    fragment = defaultFragment,\n    uniforms = {},\n    textureUniform = 'tMap',\n    enabled = true\n  } = {}) {\n    uniforms[textureUniform] = this.uniform;\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n  render() {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    enabledPasses.forEach((pass, i) => {\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: this.fbo.write,\n        clear: false\n      });\n      this.fbo.swap();\n    });\n  }\n}\nconst defaultVertex = /* glsl */`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst defaultFragment = /* glsl */`\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;","map":{"version":3,"names":["Program","Mesh","Texture","RenderTarget","Triangle","GPGPU","constructor","gl","data","Float32Array","geometry","type","initialData","passes","dataLength","length","size","Math","pow","ceil","log","sqrt","LN2","coords","i","x","y","floor","set","floatArray","a","uniform","value","image","target","TEXTURE_2D","FLOAT","format","RGBA","internalFormat","renderer","isWebgl2","RGBA32F","wrapS","CLAMP_TO_EDGE","wrapT","generateMipmaps","minFilter","NEAREST","magFilter","width","flipY","options","height","HALF_FLOAT","extensions","HALF_FLOAT_OES","RGBA16F","depth","unpackAlignment","fbo","read","write","swap","temp","texture","addPass","vertex","defaultVertex","fragment","defaultFragment","uniforms","textureUniform","enabled","program","mesh","pass","push","render","enabledPasses","filter","forEach","scene","clear"],"sources":["/Users/govikarsaiteja/companies-directory/frontend/node_modules/ogl/src/extras/GPGPU.js"],"sourcesContent":["import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Texture } from '../core/Texture.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class GPGPU {\n    constructor(\n        gl,\n        {\n            // Always pass in array of vec4s (RGBA values within texture)\n            data = new Float32Array(16),\n            geometry = new Triangle(gl),\n            type, // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n        }\n    ) {\n        this.gl = gl;\n        const initialData = data;\n        this.passes = [];\n        this.geometry = geometry;\n        this.dataLength = initialData.length / 4;\n\n        // Windows and iOS only like power of 2 textures\n        // Find smallest PO2 that fits data\n        this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2));\n\n        // Create coords for output texture\n        this.coords = new Float32Array(this.dataLength * 2);\n        for (let i = 0; i < this.dataLength; i++) {\n            const x = (i % this.size) / this.size; // to add 0.5 to be center pixel ?\n            const y = Math.floor(i / this.size) / this.size;\n            this.coords.set([x, y], i * 2);\n        }\n\n        // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n        const floatArray = (() => {\n            if (initialData.length === this.size * this.size * 4) {\n                return initialData;\n            } else {\n                const a = new Float32Array(this.size * this.size * 4);\n                a.set(initialData);\n                return a;\n            }\n        })();\n\n        // Create output texture uniform using input float texture with initial data\n        this.uniform = {\n            value: new Texture(gl, {\n                image: floatArray,\n                target: gl.TEXTURE_2D,\n                type: gl.FLOAT,\n                format: gl.RGBA,\n                internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n                wrapS: gl.CLAMP_TO_EDGE,\n                wrapT: gl.CLAMP_TO_EDGE,\n                generateMipmaps: false,\n                minFilter: gl.NEAREST,\n                magFilter: gl.NEAREST,\n                width: this.size,\n                flipY: false,\n            }),\n        };\n\n        // Create FBOs\n        const options = {\n            width: this.size,\n            height: this.size,\n            type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n            format: gl.RGBA,\n            internalFormat: gl.renderer.isWebgl2 ? (type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F) : gl.RGBA,\n            minFilter: gl.NEAREST,\n            depth: false,\n            unpackAlignment: 1,\n        };\n\n        this.fbo = {\n            read: new RenderTarget(gl, options),\n            write: new RenderTarget(gl, options),\n            swap: () => {\n                let temp = this.fbo.read;\n                this.fbo.read = this.fbo.write;\n                this.fbo.write = temp;\n                this.uniform.value = this.fbo.read.texture;\n            },\n        };\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = this.uniform;\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    render() {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        enabledPasses.forEach((pass, i) => {\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: this.fbo.write,\n                clear: false,\n            });\n            this.fbo.swap();\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}